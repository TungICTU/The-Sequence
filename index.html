<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Sequence Protocol — Patterns + Glow (Fixed)</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7dd3fc;--muted:#94a3b8;--danger:#fb7185}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:linear-gradient(180deg,#071021 0%, #081328 100%);color:#e6eef8}
    .app{max-width:600px;margin:0 auto;padding:10px}
    header{display:flex;flex-direction:column;gap:8px;margin-bottom:14px;text-align:center}
    header h1{font-size:18px;margin:0}
    .hud{display:flex;gap:6px;justify-content:center;flex-wrap:wrap}
    .stat{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:10px;min-width:90px;text-align:center}
    .stat small{display:block;color:var(--muted);font-size:12px}
    .board{background:var(--card);border-radius:12px;padding:12px;margin-top:10px;box-shadow:0 6px 30px rgba(2,6,23,0.7)}
    .sequence{font-size:22px;letter-spacing:2px;margin:12px 0;text-align:center;word-break:break-word}
    .slot{display:inline-block;padding:4px 8px;background:rgba(255,255,255,0.02);border-radius:8px;margin:0 4px;min-width:34px;text-align:center}
    .slot.question{background:linear-gradient(90deg, rgba(125,211,252,0.08), rgba(125,211,252,0.03));border:1px dashed rgba(125,211,252,0.2)}
    .slot.active-question{border:2px solid var(--accent) !important;background:rgba(125,211,252,0.12) !important;box-shadow:0 0 10px var(--accent);}
    .controls{display:flex;flex-direction:column;gap:8px;align-items:center;margin-top:14px}
    .num-input{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;font-size:16px;text-align:center}
    button{padding:10px 14px;border-radius:10px;border:0;background:var(--accent);color:#022;cursor:pointer;width:100%}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .hint{width:100%}
    .panel{display:none}
    .small{font-size:13px;color:var(--muted)}
    .lives{color:var(--danger);font-weight:600}
    .big{font-size:18px;font-weight:700}
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:30px;background:#062433;padding:10px 16px;border-radius:10px;border:1px solid rgba(125,211,252,0.12);}
    
    .keyboard button{font-size:18px;padding:12px 6px}
    #restartBtn{margin-top:12px}
    @media (max-width:420px){
      .sequence{font-size:18px}
      .slot{min-width:28px;padding:6px}
    }
  
@keyframes difficulty-flash {
  0%   { box-shadow: 0 0 0px var(--flash-color); }
  50%  { box-shadow: 0 0 20px var(--flash-color); }
  100% { box-shadow: 0 0 0px var(--flash-color); }
}
.board.flash {
  animation: difficulty-flash 1s ease-out 2;
}
.difficulty-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  font-size: 28px;
  font-weight: bold;
  color: white;
  text-shadow: 0 0 10px black;
  opacity: 1;
  pointer-events: none;
  animation: diff-msg 1.2s ease-out forwards;
  z-index: 9999;
}
@keyframes diff-msg {
  0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -70%) scale(1.5); }
}







.keyboard {
  display: flex;
  flex-direction: column; /* stack the rows */
  align-items: center;    /* center the whole keypad */
}
.key-row {
  display: flex;
  justify-content: center;
  margin-bottom: 4px;
}
.key-row button, .key-spacer {
  width: 60px;
  height: 50px;
  margin: 2px;
  font-size: 18px;
}
.key-spacer {
  background: transparent;
  border: none;
}

</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>The Sequence Protocol — Prototype</h1>
      <div class="hud">
        <div class="stat"><small>Timer</small><div id="timer" class="big">00:30</div></div>
        <div class="stat"><small>Score</small><div id="score" class="big">0</div></div>
        <div class="stat"><small>Level</small><div id="level" class="big">1</div></div>
        <div class="stat"><small>Lives</small><div id="lives" class="big lives">3</div></div>
      </div>
    </header>

    <div class="board">
      <div class="small">Streak: <span id="streak">0</span></div>
      <div id="sequenceArea" class="sequence" aria-live="polite">Loading sequence...</div>
      <div class="controls">
        <input id="numInput" class="num-input" type="text" inputmode="numeric" placeholder="Enter number" />
        <div class="keyboard" id="keyboard"></div>
        <button id="nextBtn" class="ghost">Skip (-1 life)</button>
        <div class="hint"><button id="hintBtn" class="ghost">Reveal Sequence (<span id="hintsRemaining">3</span>)</button></div>
      </div>
      <div class="panel">
        <div class="col">
          <div class="small">Active rule hint</div>
          <div id="ruleHint" style="margin-top:8px;font-weight:600">—</div>
        </div>
      </div>
    </div>
    <div id="hintBox" style="display:none;margin-top:12px;padding:8px;border-radius:10px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);text-align:center;font-weight:600"></div>

    <div id="difficultyOverlay" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);padding:20px 40px;background:rgba(0,0,0,0.8);color:#fff;font-size:24px;font-weight:bold;border-radius:12px;z-index:2000;opacity:0;transition:opacity 0.5s;"></div>

    <div id="toast" class="toast" style="display:none"></div>
    <button id="restartBtn" style="display:none">Restart Game</button>
  </div>

  <script>
// Cleaned main script
(function(){
  // Elements
  const timerEl = document.getElementById('timer');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const seqArea = document.getElementById('sequenceArea');
  const numInput = document.getElementById('numInput');
  const nextBtn = document.getElementById('nextBtn');
  const hintBtn = document.getElementById('hintBtn');
  const hintsRemainingEl = document.getElementById('hintsRemaining');
  const ruleHintEl = document.getElementById('ruleHint');
  const streakEl = document.getElementById('streak');
  const toast = document.getElementById('toast');
  const restartBtn = document.getElementById('restartBtn');
  const keyboardEl = document.getElementById('keyboard');
  const levelEl = document.getElementById('level');
  const boardEl = document.querySelector('.board') || document.body;
  const hintBox = document.getElementById('hintBox');
  const difficultyOverlay = document.getElementById('difficultyOverlay');

  // state
  let score = 0, lives = 3, timeLeft = 60, timerInterval = null;
  let current = null;
  let hintsRemaining = 3, streak = 0;
  let level = 1, sequencesCompleted = 0;
  let difficultyStages = ['easy','medium','hard'];
  let difficultyIndex = 0;

  function getCurrentDifficulty(){ return difficultyStages[difficultyIndex]; }

  function showToast(txt, ms=1400){
    if(!toast) return;
    toast.textContent = txt;
    toast.style.display='block';
    setTimeout(()=> toast.style.display='none', ms);
  }

  function showDifficultyIncreaseVisual(newDiff){
    if(!difficultyOverlay) return;
    difficultyOverlay.textContent = 'DIFFICULTY: ' + (newDiff||'').toUpperCase();
    difficultyOverlay.style.display = 'block';
    difficultyOverlay.style.opacity = '1';
    setTimeout(()=>{
      difficultyOverlay.style.opacity = '0';
      setTimeout(()=> difficultyOverlay.style.display='none', 500);
    }, 1400);
  }

  function startTimer(){
    clearInterval(timerInterval);
    timeLeft = 60;
    updateTimer();
    timerInterval = setInterval(()=>{ timeLeft--; updateTimer(); if(timeLeft<=0) onTimeout(); },1000);
  }
  function updateTimer(){ const mm = String(Math.floor(timeLeft/60)).padStart(2,'0'); const ss = String(timeLeft%60).padStart(2,'0'); if(timerEl) timerEl.textContent = mm+':'+ss; }

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function randLength(min=4,max=9){ return randInt(min,max); }

  function pickBlanks(len){
    const curDiff = getCurrentDifficulty();
    if((len === 4 || len === 5) && (curDiff === 'medium' || curDiff === 'hard')){
      return [ randInt(1, Math.max(1, len-1)) ];
    }
    let possibleCounts;
    if(level <= 10) possibleCounts = [1,2];
    else if(level <= 20) possibleCounts = [1,2,3];
    else if(level <= 30) possibleCounts = [2,3];
    else possibleCounts = [3];
    const blanksToPick = possibleCounts[ randInt(0, possibleCounts.length - 1) ];
    const blanks = [];
    while(blanks.length < blanksToPick){
      const idx = randInt(1, Math.max(1, len-1));
      if(!blanks.includes(idx)) blanks.push(idx);
    }
    blanks.sort((a,b)=>a-b);
    return blanks;
  }

  function maybeReverse(arr){ return Math.random() < 0.5 ? arr.slice().reverse() : arr; }

  const generators = {
    easy(){
      const len = randLength();
      const type = randInt(1,5);
      let arr=[], rule='Easy';
      if(type===1){
        const start = randInt(1,9), step = randInt(1,6);
        arr = Array.from({length:len}, (_,i)=> start + step*i);
        rule = `Add ${step} each time (start ${start})`;
      } else if(type===2){
        const start = randInt(10,50), step = randInt(1,6);
        arr = Array.from({length:len}, (_,i)=> start - step*i);
        rule = `Subtract ${step} each time (start ${start})`;
      } else if(type===3){
        const start = randInt(1,12), add = randInt(1,5), sub = randInt(1,4);
        arr=[start];
        for(let i=1;i<len;i++) arr.push(i%2===1 ? arr[i-1]+add : arr[i-1]-sub);
        rule = `Add ${add}, then subtract ${sub}, repeat (start ${start})`;
      } else if(type===4){
        // triangular
        arr = Array.from({length:len}, (_,i)=> (i+1)*(i+2)/2);
        rule = `Triangular numbers`;
      } else {
        // arithmetic small
        const start = randInt(1,12), step = randInt(1,4);
        arr = Array.from({length:len}, (_,i)=> start + step*i);
        rule = `Add ${step} each time (start ${start})`;
      }
      arr = maybeReverse(arr);
      const blanks = pickBlanks(len);
      const answers = blanks.map(i=>arr[i]);
      return {arr, blanks, answers, ruleText: rule};
    },

    medium(){
      const len = randLength();
      const type = randInt(1,9);
      let arr=[], rule='Medium';
      if(type===1){
        const res = generators.easy(); arr = res.arr; rule = res.ruleText || 'Easy-like';
      } else if(type===2){
        const start = randInt(1,4), mul = randInt(2,5);
        arr = Array.from({length:len}, (_,i)=> start * (mul**i));
        rule = `Multiply by ${mul} each time (start ${start})`;
      } else if(type===3){
        const mul = randInt(2,4);
        const base = Math.pow(mul, len-1) * randInt(1,5);
        arr = Array.from({length:len}, (_,i)=> Math.floor(base / (mul**i)));
        rule = `Divide by ${mul} each time (approx integer)`;
      } else if(type===4){
        const start = randInt(1,4), mul = randInt(2,5), add = randInt(1,6);
        arr=[start]; for(let i=1;i<len;i++) arr.push(arr[i-1]*mul + add);
        rule = `Multiply by ${mul}, then add ${add} (start ${start})`;
      } else if(type===5){
        const start = randInt(5,20), sub = randInt(1,6), add = randInt(1,6);
        arr=[start]; for(let i=1;i<len;i++) arr.push(arr[i-1] - sub + add);
        rule = `Subtract ${sub}, then add ${add} (start ${start})`;
      } else if(type===6){
        const start = randInt(1,5), mul = randInt(2,4), add = randInt(1,5);
        arr=[start]; for(let i=1;i<len;i++) arr.push(i%2===1 ? arr[i-1]*mul : arr[i-1]+add);
        rule = `Multiply by ${mul}, then add ${add}, repeat (start ${start})`;
      } else if(type===7){
        // primes
        const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61];
        const startIdx = randInt(0, Math.max(0, primes.length - len));
        arr = primes.slice(startIdx, startIdx+len);
        rule = `Prime numbers in order`;
      } else {
        // geometric then add
        const start = randInt(1,6), mul = randInt(2,4), add = randInt(0,5);
        arr=[start]; for(let i=1;i<len;i++) arr.push(arr[i-1]*mul + add);
        rule = `Multiply by ${mul}, then add ${add} (start ${start})`;
      }
      arr = maybeReverse(arr);
      const blanks = pickBlanks(len);
      const answers = blanks.map(i=>arr[i]);
      return {arr, blanks, answers, ruleText: rule};
    },

    hard(){
      const len = randLength();
      const type = randInt(1,10);
      let arr=[], rule='Hard';
      if(type<=2){
        const res = generators.medium(); arr = res.arr; rule = res.ruleText || 'Medium-like';
      } else if(type===3){
        arr=[randInt(1,5), randInt(1,5)];
        for(let i=2;i<len;i++) arr.push(arr[i-1] + arr[i-2]);
        rule = `Each number is the sum of the previous two (Fibonacci-like)`;
      } else if(type===4){
        const start = randInt(1,5);
        arr = Array.from({length:len}, (_,i)=> (start + i) ** 2);
        rule = `Square of consecutive numbers starting at ${start}`;
      } else if(type===5){
        const start = randInt(1,4);
        arr = Array.from({length:len}, (_,i)=> (start + i) ** 3);
        rule = `Cube of consecutive numbers starting at ${start}`;
      } else if(type===6){
        const start = randInt(2,5), mul = randInt(2,4), sub = randInt(1,5);
        arr=[start]; for(let i=1;i<len;i++) arr.push(arr[i-1]*mul - sub);
        rule = `Multiply by ${mul}, then subtract ${sub} (start ${start})`;
      } else if(type===7){
        const start = randInt(2,6), sub = randInt(1,4), mul = randInt(2,3);
        arr=[start]; for(let i=1;i<len;i++) arr.push(i%2===1 ? arr[i-1] - sub : arr[i-1]*mul);
        rule = `Subtract ${sub}, then multiply by ${mul}, repeat (start ${start})`;
      } else if(type===8){
        const start = randInt(1,5), add = randInt(1,4), mul = randInt(2,4);
        arr=[start]; for(let i=1;i<len;i++) arr.push(i%2===1 ? arr[i-1] + add : arr[i-1]*mul);
        rule = `Add ${add}, then multiply by ${mul}, repeat (start ${start})`;
      } else {
        // quadratic-ish sequence: n^2 + n
        const start = randInt(0,3);
        arr = Array.from({length:len}, (_,i)=> (start + i)**2 + (start + i));
        rule = `Quadratic pattern n^2 + n (start ${start})`;
      }
      arr = maybeReverse(arr);
      const blanks = pickBlanks(len);
      const answers = blanks.map(i=>arr[i]);
      return {arr, blanks, answers, ruleText: rule};
    }
  };

  function normalizeBlanks(out){
    if(!out || !Array.isArray(out.blanks)) return out;
    if(!Array.isArray(out.answers) || out.answers.length !== out.blanks.length){
      out.answers = out.blanks.map(i=>out.arr[i]);
    } else {
      out.answers = out.answers.map(a=>Number(a));
    }
    const pairs = out.blanks.map((b,i)=> ({b:b, ans: Number(out.answers[i])}));
    pairs.sort((x,y)=> x.b - y.b);
    out.blanks = pairs.map(p=>p.b);
    out.answers = pairs.map(p=>p.ans);
    return out;
  }

  function generateSequence(){
    const outRaw = generators[getCurrentDifficulty()]();
    const out = normalizeBlanks(outRaw);
    current = { arr: out.arr.slice(), blanks: out.blanks.slice(), answers: out.answers.slice(), ruleText: out.ruleText || out.hint || 'Pattern' };
    console.groupCollapsed('Generated sequence'); console.log(out.arr); console.log('blanks', out.blanks); console.log('answers', out.answers); console.groupEnd();
    renderSequence();
  }

  function renderSequence(){
    if(!current || !Array.isArray(current.arr)) return;
    const parts = current.arr.map((n,i)=>{
      if(Array.isArray(current.blanks) && current.blanks.includes(i)){
        let cls = 'slot question'; if(i === current.blanks[0]) cls += ' active-question';
        return `<span class="${cls}" data-idx="${i}">?</span>`;
      }
      return `<span class="slot">${n}</span>`;
    });
    seqArea.innerHTML = parts.join(', ');
    if(ruleHintEl) ruleHintEl.textContent = '—';
  }

  function checkAnswer(){
    const val = (numInput.value || '').toString().trim();
    if(val === ''){ showToast('Enter a number'); return; }
    const num = Number(val); if(Number.isNaN(num)){ showToast('Invalid number'); numInput.value=''; return; }
    if(!current || !Array.isArray(current.blanks) || current.blanks.length === 0){ showToast('No blanks — press Next'); numInput.value=''; return; }
    const idx = current.blanks[0]; const correct = Number(current.answers[0]);
    if(num === correct){
      current.arr[idx] = correct; current.blanks.shift(); current.answers.shift();
      score += 10 + Math.floor(10*(streak*0.2)); streak++; updateHUD(); renderSequence(); showToast('Correct! +10');
      if(!current.blanks || current.blanks.length === 0){
        score += Math.max(0,5*streak); sequencesCompleted++; level++; levelEl.textContent = level;
        // hide hint box when sequence completes
        if(hintBox) hintBox.style.display='none';
        if(sequencesCompleted % 5 === 0 && difficultyIndex < difficultyStages.length - 1){
          difficultyIndex++; showDifficultyIncreaseVisual(getCurrentDifficulty());
        }
        generateSequence(); startTimer();
      }
    } else {
      lives--; streak = 0; updateHUD(); showToast('Wrong — life lost'); if(lives <= 0){ endGame(); return; }
    }
    numInput.value='';
  }

  function skipSequence(){ lives--; updateHUD(); generateSequence(); startTimer(); showToast('Skipped (−1 life)'); if(lives<=0) endGame(); }

  function useHint(){
    if(!current){ showToast('No active sequence'); return; }
    if(hintsRemaining <= 0){ showToast('No hints left'); return; }
    hintsRemaining--; if(hintsRemainingEl) hintsRemainingEl.textContent = hintsRemaining;
    if(hintBox) { hintBox.textContent = current.ruleText || '—'; hintBox.style.display = 'block'; }
    showToast('Hint shown');
  }

  function onTimeout(){ lives--; streak = 0; updateHUD(); showToast('Time up — life lost'); if(lives <= 0){ endGame(); return; } generateSequence(); startTimer(); }

  function updateHUD(){ if(scoreEl) scoreEl.textContent = score; if(livesEl) livesEl.textContent = lives; if(hintsRemainingEl) hintsRemainingEl.textContent = hintsRemaining; if(streakEl) streakEl.textContent = streak; if(levelEl) levelEl.textContent = level; }

  function endGame(){ clearInterval(timerInterval); showToast('Game Over',2000); seqArea.textContent = 'GAME OVER'; restartBtn.style.display = 'block'; }

  function restartGame(){ score=0; lives=3; hintsRemaining=3; streak=0; sequencesCompleted=0; level=1; difficultyIndex=0; updateHUD(); generateSequence(); startTimer(); restartBtn.style.display='none'; showToast('Restarted'); }

  // keyboard builder - do not change layout; simple buttons
  (function buildKeyboard(){
    if(!keyboardEl) return;
    keyboardEl.innerHTML='';
    const layout = [
      ['1','2','3'],
      ['4','5','6'],
      ['7','8','9'],
      ['-','0','⌫'],
      ['','OK','']
    ];
    layout.forEach(row=>{
      const rowDiv = document.createElement('div'); rowDiv.className='key-row';
      row.forEach(k=>{
        if(k===''){ const spacer = document.createElement('div'); spacer.className='key-spacer'; rowDiv.appendChild(spacer); return; }
        const btn = document.createElement('button');
        if(k==='⌫'){ btn.textContent='⌫'; btn.addEventListener('click', ()=>{ numInput.value = (numInput.value||'').toString().slice(0,-1); }); }
        else if(k==='OK'){ btn.textContent='OK'; btn.addEventListener('click', ()=> checkAnswer()); }
        else { btn.textContent = k; btn.addEventListener('click', ()=> { numInput.value = (numInput.value||'').toString() + k; }); }
        rowDiv.appendChild(btn);
      });
      keyboardEl.appendChild(rowDiv);
    });
  })();

  // Listeners
  nextBtn && nextBtn.addEventListener('click', skipSequence);
  hintBtn && hintBtn.addEventListener('click', useHint);
  restartBtn && restartBtn.addEventListener('click', restartGame);
  numInput && numInput.addEventListener('keydown', e=>{ if(e.key==='Enter') checkAnswer(); });

  // window error catcher
  window.onerror = function(msg, src, line, col, err){ console.error('Caught', msg, 'at', src+':'+line+':'+col, err); showToast('Error: '+ (msg && msg.toString().slice(0,48)), 4000); };

  // start
  updateHUD(); generateSequence(); startTimer();
})();</script>

</body>
</html>
